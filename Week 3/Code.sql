
/*
ACID
	Atomicity: The entire transaction takes place at once or doens't happen at all.
	Consistency: The database must be consistent before and after the transaction.
	Isolation: Multiple transactions occur independently without interference.
	Durability: The changes of a successful transaction occurs even if the system faliure occurs.
*/


BEGIN TRANSACTION;
ROLLBACK;
-- or
COMMIT;



-- rolling back stuff

BEGIN TRANSACTION;

DELETE FROM
	TEST
WHERE
	Gender = 'Male';

ROLLBACK;


SELECT
	*
FROM
	TEST;



-- Normal way of creating a table with one primary key

CREATE TABLE Users (
	Id INT PRIMARY KEY,
	Username NVARCHAR(MAX),
	Fullame NVARCHAR(MAX)
)

-- With two primary keys.
-- NOTE: MAX doens't work here.

CREATE TABLE Users (
	Id INT,
	Username NVARCHAR(50),
	Fullame NVARCHAR(50),
	CONSTRAINT PK_Users PRIMARY KEY (Id, Username)
)



-- table based constraints

CREATE TABLE Users (
	Id INT PRIMARY KEY,
	Minutes INT CHECK(Minutes > 10 AND Minutes < 15)
)



-- Misc
CREATE TABLE Users (
	Id INT PRIMARY KEY,
	Minutes INT DEFAULT(69),
	Minutes2 INT DEFAULT(GETDATE())
)



-- Views

CREATE VIEW
	OldUsers
AS
-- The view runs the below code
SELECT
	ID,
	FirstName,
	LastName
FROM
	Users
WHERE
	ID < '6';


SELECT * FROM OldUsers


-- Procedures
CREATE PROCEDURE
	test
AS
BEGIN
	PRINT 'TEST';
END

-- NOTE: Normal operations (e.g DROP TABLE) work the same with views/procedures.



-- if statements
IF EXISTS (
	SELECT
		*
	FROM
		Butiker
	WHERE
		ID = 2
)
BEGIN
	PRINT 'FOUND'
END;




-- loops


-- set based. server side
DECLARE @count INT = 0;

WHILE @count <= 10
BEGIN
	print 'LOOP'
	SET @count += 1
END



-- imparative, bad practice'ish.

-- Declare a variable, set as (FAST_FORWARD) CURSOR type, than decide the
-- operation (the select) to be ran
DECLARE myCursor CURSOR FAST_FORWARD for
SELECT
	id,
	FirstName
FROM
	users;

-- Open cursor
OPEN myCursor;

-- Declare variables for the cursor to return to
DECLARE @id NVARCHAR(MAX);
DECLARE @name NVARCHAR(MAX);

-- Fetch once in order to make the below loop, which relies on @@FETCH_STATUS work.
-- This doesn't skip over the first element as we're using the fetched values in the loop.
FETCH NEXT FROM
	myCursor
	INTO
		@id, @name;

-- Run a while loop, use the @@FETCH_STATUS server variable. The variable gets set to 1 when
-- the server is done iterating through all (in this case) rows.
WHILE @@FETCH_STATUS = 0
BEGIN
	PRINT convert(VARCHAR, @id) + ' = ' + @name; 
	-- insert into myTable2 values (@id, @name);
	
	-- Fetch more values for next iteration.
	FETCH NEXT FROM
	myCursor
		INTO @id, @name; 
END;

-- Dispose
CLOSE myCursor; 
DEALLOCATE myCursor;


-- Generate series

select * from generate_series(1, 10, 1);


-- value is in this case the column name of the "table" thats generated by GENERATE_SERIES()
SELECT DATEADD(DAY, value, '2020-01-01') FROM GENERATE_SERIES(1, 10, 1);